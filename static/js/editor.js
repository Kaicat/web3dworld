// Generated by CoffeeScript 1.4.0
(function() {

  $(function() {
    var Editor2DView, Editor3DView, EditorView, EditorViewport, EditorViewportDelegate, animate, editor, editor2dview, editor3dview, editor3dviewanimate, height, helper, static_url, viewport2d, viewport3d, viewportDelegate, width;
    static_url = '/static/';
    window.scenes = [];
    window.floors = [];
    helper = window.helper;
    EditorViewport = Backbone.Model.extend({
      loadSceneFromJson: function(json) {
        this.loadFloorFromJson(json.floor);
        this.loadWallsFromJson(json.walls);
        this.loadSkyboxFromJson(json.skybox);
        this.loadFogFromJson(json.fog);
        return this.loadLightsFromJson(json.lights);
      },
      loadScene: function(sceneUrl) {
        if (this.get('scene') === void 0) {
          this.initScene();
        }
        return helper.loadSceneJson(sceneUrl, _.bind(this.loadSceneFromJson, this));
      },
      initialize: function() {
        this.initUtils();
        this.initScene();
        this.initDerectionHelp();
        this.initControls();
        this.initEvents();
        this.initFloor();
        return this.loadScene(static_url + 'resources/scenes/test.json');
      },
      initFloor: function() {
        var floor, floorGeometry, floorMaterial, floorTexture, jsonLoader, proportion, scene;
        scene = this.get('scene');
        jsonLoader = this.get('jsonLoader');
        floorTexture = THREE.ImageUtils.loadTexture(static_url + 'img/checkerboard.jpg');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(10, 10);
        floorMaterial = new THREE.MeshBasicMaterial({
          map: floorTexture
        });
        floorGeometry = new THREE.PlaneGeometry(2000, 2000, 10, 10);
        floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.set(0, 0, 0);
        proportion = 1.0;
        helper.scaleObject3D(floor, proportion);
        floor.doubleSided = true;
        scene.add(floor);
        return this.set('floorboard', floor);
      },
      loadFloorFromJson: function(json) {
        var floor, floorboard, geom, material, oldFloor, scene;
        if (this.get('floorboard') === void 0) {
          this.initFloor();
        }
        scene = this.get('scene');
        floorboard = this.get('floorboard');
        floorboard.visible = false;
        oldFloor = this.get('floor');
        if (oldFloor !== void 0) {
          scene.remove(oldFloor);
          this.set('floor', void 0);
        }
        geom = new THREE.PlaneGeometry(json.width, json.height, json.widthSegments, json.heightSegments);
        material = helper.loadMaterialFromJson(json.material);
        floor = new THREE.Mesh(geom, material);
        scene.add(floor);
        helper.updateMeshFromJson(floor, json);
        return this.set('floor', floor);
      },
      loadFloor: function(textureUrl, width, height) {
        var floor, floorboard, geom, material, oldFloor, scene, texture;
        if (width == null) {
          width = 2000;
        }
        if (height == null) {
          height = 2000;
        }
        scene = this.get('scene');
        floorboard = this.get('floorboard');
        floorboard.visible = false;
        oldFloor = this.get('floor');
        if (oldFloor !== void 0) {
          scene.remove(oldFloor);
          this.set('floor', void 0);
        }
        geom = new THREE.PlaneGeometry(width, height, 10, 10);
        texture = THREE.ImageUtils.loadTexture(textureUrl);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        texture.repeat.set(width / 50, height / 50);
        material = new THREE.MeshBasicMaterial({
          map: texture
        });
        floor = new THREE.Mesh(geom, material);
        floor.doubleSided = true;
        scene.add(floor);
        return this.set('floor', floor);
      },
      loadWallsFromJson: function(json) {
        var jsonLoader, scene, wall, wallJson, _i, _len, _results;
        jsonLoader = this.get('jsonLoader');
        scene = this.get('scene');
        _results = [];
        for (_i = 0, _len = json.length; _i < _len; _i++) {
          wallJson = json[_i];
          wall = helper.loadWallFromJson(wallJson);
          _results.push(scene.add(wall));
        }
        return _results;
      },
      loadWall: function(geomUrl, textureUrl, proportion, rotation) {
        var jsonLoader, scene;
        if (proportion == null) {
          proportion = 1.0;
        }
        if (rotation == null) {
          rotation = {
            x: 0,
            y: 0,
            z: 0
          };
        }
        jsonLoader = this.get('jsonLoader');
        scene = this.get('scene');
        return jsonLoader.load(geomUrl, function(geom) {
          var material, mesh, texture;
          texture = THREE.ImageUtils.loadTexture(textureUrl);
          texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(10, 10);
          material = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.5
          });
          mesh = new THREE.Mesh(geom, material);
          mesh.receiveShadow = true;
          mesh.doubleSided = true;
          mesh.rotation.x = rotation.x;
          mesh.rotation.y = rotation.y;
          mesh.rotation.z = rotation.z;
          mesh.scale.x *= proportion;
          mesh.scale.y *= proportion;
          mesh.scale.z /= proportion;
          mesh.castShadow = true;
          return scene.add(mesh);
        });
      },
      loadSkyboxFromJson: function(json) {
        var geom, material, scene, skybox;
        scene = this.get('scene');
        geom = new THREE.CubeGeometry(json.width, json.height, json.depth);
        material = helper.loadMaterialFromJson(json.material);
        skybox = new THREE.Mesh(geom, material);
        helper.updateMeshFromJson(skybox, json);
        scene.add(skybox);
        return this.set('skybox', skybox);
      },
      initSkybox: function() {
        var geom, material, scene, skybox;
        scene = this.get('scene');
        geom = new THREE.CubeGeometry(10000, 10000, 10000);
        material = new THREE.MeshBasicMaterial({
          color: "#9999ff"
        });
        skybox = new THREE.Mesh(geom, material);
        skybox.flipSided = true;
        scene.add(skybox);
        return this.set('skybox', skybox);
      },
      loadFogFromJson: function(json) {
        var scene;
        scene = this.get('scene');
        return scene.fog = new THREE.FogExp2(json.color, json.density);
      },
      initFog: function() {
        var scene;
        scene = this.get('scene');
        return scene.fog = new THREE.FogExp2("#9999ff", 0.00025);
      },
      initDerectionHelp: function() {
        var scene, selectionAxis;
        scene = this.get('scene');
        helper.addAxis(scene, 2.0);
        selectionAxis = new THREE.AxisHelper(100);
        selectionAxis.material.depthTest = false;
        selectionAxis.material.transparent = true;
        selectionAxis.matrixAutoUpdate = false;
        selectionAxis.visible = false;
        return scene.add(selectionAxis);
      },
      initUtils: function() {
        return this.set('jsonLoader', new THREE.JSONLoader);
      },
      initScene: function() {
        var scene;
        scene = new THREE.Scene;
        return this.set('scene', scene);
      },
      initControls: function() {
        var intersectionPlane, scene;
        scene = this.get('scene');
        intersectionPlane = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000, 8, 8));
        intersectionPlane.visible = false;
        scene.add(intersectionPlane);
        return this.set('intersectionPlane', intersectionPlane);
      },
      loadLightsFromJson: function(json) {
        var light, lightJson, lights, scene, _i, _len, _results;
        scene = this.get('scene');
        if (this.get('lights') === void 0) {
          this.set('lights', []);
        }
        lights = this.get('lights');
        _results = [];
        for (_i = 0, _len = json.length; _i < _len; _i++) {
          lightJson = json[_i];
          light = helper.loadLightFromJson(lightJson);
          lights.push(light);
          scene.add(light);
          _results.push(helper.updateMeshFromJson(light, lightJson));
        }
        return _results;
      },
      initLight: function() {
        var light, scene;
        scene = this.get('scene');
        light = new THREE.DirectionalLight("#ff0000", 1.0, 0);
        this.set('light', light);
        light.position.set(500, 250, 500);
        scene.add(light);
        return scene.add(new THREE.AmbientLight("#ff0000"));
      },
      onAddMeshByJson: function(meshJson) {
        var mesh, scene;
        scene = this.get('scene');
        switch (meshJson.meshType) {
          case 'wall':
            mesh = helper.loadWallFromJson(meshJson);
            return scene.add(mesh);
          case 'walls':
            return this.loadWallsFromJson(meshJson);
        }
      },
      initEvents: function() {
        return this.on('addMeshByJson', this.onAddMeshByJson, this);
      }
    });
    EditorViewportDelegate = Backbone.Model.extend({
      initialize: function() {
        this.set('viewports', []);
        return this.on('all', function() {
          var viewports, _arguments;
          _arguments = _.toArray(arguments);
          viewports = this.get('viewports');
          return _.each(viewports, function(viewport) {
            return viewport.trigger.apply(viewport, _arguments);
          });
        });
      },
      addViewport: function(viewport) {
        var viewports;
        viewports = this.get('viewports');
        return viewports.push(viewport);
      }
    });
    EditorView = Backbone.View.extend({
      initRenderer: function() {
        var renderer;
        this.renderer = renderer = new THREE.WebGLRenderer({
          antialias: true,
          precision: 'highp',
          alpha: true,
          preserveDrawingBuffer: true,
          maxLights: 5
        });
        renderer.setSize(this.width, this.height);
        renderer.setClearColor(0xffffff, 0.1);
        return this.el.appendChild(renderer.domElement);
      },
      initCamera: function() {},
      initProjector: function() {
        var cameraChanged, helpersVisible, intersectionPlane, offset, picked, projector, ray, scene, selected, _this;
        scene = this.model.get('scene');
        intersectionPlane = this.model.get('intersectionPlane');
        ray = new THREE.Raycaster();
        projector = new THREE.Projector();
        offset = new THREE.Vector3();
        cameraChanged = false;
        helpersVisible = true;
        picked = null;
        selected = this.camera;
        _this = this;
        this.$el.mousedown(function(event) {
          var intersects, root, vector;
          _this.el.focus();
          if (!_this.selectionAvailable) {
            return;
          }
          if (event.button === 0) {
            vector = new THREE.Vector3((event.offsetX / _this.width) * 2 - 1, -(event.offsetY / _this.height) * 2 + 1, 0.5);
            projector.unprojectVector(vector, _this.camera);
            ray.set(_this.camera.position, vector.sub(_this.camera.position).normalize());
            intersects = ray.intersectObjects(scene.children, true);
            if (intersects.length > 0) {
              if (_this.controls) {
                _this.controls.enabled = false;
              }
              picked = intersects[0].object;
              if (picked.properties.isGizmo) {
                root = picked.properties.gizmoRoot;
                selected = picked.properties.gizmoSubject;
              } else {
                root = picked;
                selected = picked;
              }
              intersectionPlane.position.copy(root.position);
              intersectionPlane.lookAt(_this.camera.position);
              console.log('mouse down: ', selected);
              return _this.mousemoveAvailable = _this.mouseupavailable = true;
            }
          }
        });
        this.$el.mousemove(function(event) {
          var intersects, vector;
          if (_this.mousemoveAvailable) {
            vector = new THREE.Vector3((event.offsetX / _this.width) * 2 - 1, -(event.offsetY / _this.height) * 2 + 1, 0.5);
            projector.unprojectVector(vector, _this.camera);
            ray.set(_this.camera.position, vector.sub(_this.camera.position).normalize());
            intersects = ray.intersectObject(intersectionPlane);
            if (intersects.length > 0) {
              intersects[0].point.sub(offset);
              if (picked.properties.isGizmo) {
                picked.properties.gizmoRoot.position.copy(intersects[0].point);
                picked.properties.gizmoSubject.position.copy(intersects[0].point);
                console.log('mouse move subject: ', picked.properties.gizmoSubject);
              } else {
                picked.position.copy(intersects[0].point);
                console.log('mouse move subject: ', picked.properties.gizmoSubject);
              }
              return _this.update();
            }
          }
        });
        return this.$el.mouseup(function(event) {
          if (_this.mouseupavailable) {
            _this.mousemoveAvailable = false;
            _this.mouseupavailable = false;
            if (_this.controls !== void 0) {
              return _this.controls.enabled = true;
            }
          }
        });
      },
      update: function() {
        return this.renderOnce();
      },
      initialize: function() {
        this.width = this.options.width;
        this.height = this.options.height;
        this.selectionAvailable = false;
        this.initCamera();
        this.initProjector();
        this.initRenderer();
        this.initEvents();
        return this.animate();
      },
      animate: function() {
        return animate(this);
      },
      renderOnce: function() {
        return this.renderer.render(this.model.get('scene'), this.camera);
      },
      initEvents: function() {
        var _camera, _model;
        _model = this.model;
        return _camera = this.camera;
      }
    });
    Editor2DView = EditorView.extend({
      initCamera: function() {
        var aspect, camera, far, near, view_angle;
        view_angle = 100;
        aspect = this.width / this.height;
        near = 1.0;
        far = 5000;
        this.camera = camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);
        camera.position.set(0, 0, 500);
        camera.rotation.set(-1.57, 0, 0);
        camera.up.set(0, 0, 1);
        return camera.lookAt(this.model.get('scene').position);
      },
      initEvents: function() {
        var _camera, _model;
        _model = this.model;
        _camera = this.camera;
        return this.$el.bind('mousewheel', function(event, delta) {
          if (delta < 0) {
            _camera.position.x *= 1.1;
            _camera.position.y *= 1.1;
            return _camera.position.z *= 1.1;
          } else {
            _camera.position.x *= 0.9;
            _camera.position.y *= 0.9;
            return _camera.position.z *= 0.9;
          }
        });
      }
    });
    Editor3DView = EditorView.extend({
      initialize: function() {
        return EditorView.prototype.initialize.apply(this, arguments);
      },
      initCamera: function() {
        var aspect, camera, controls, far, near, view_angle;
        view_angle = 50;
        aspect = this.width / this.height;
        near = 1.0;
        far = 5000;
        this.camera = camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);
        camera.position.set(500, 1500, 500);
        camera.rotation.set(-0.46, 0.73, 0.32);
        camera.up.set(0, 0, 1);
        camera.lookAt(this.model.get('scene').position);
        this.controls = controls = new THREE.TrackballControls(camera, this.el);
        return controls.enabled = true;
      },
      initEvents: function() {},
      animate: function() {
        return editor3dviewanimate(this);
      }
    });
    animate = function(view) {
      requestAnimationFrame(function() {
        return animate(view);
      });
      return view.update();
    };
    editor3dviewanimate = function(view) {
      requestAnimationFrame(function() {
        return editor3dviewanimate(view);
      });
      view.update();
      return view.controls.update();
    };
    if (window.editor === void 0) {
      window.editor = {};
    }
    editor = window.editor;
    viewport2d = new EditorViewport;
    viewport3d = new EditorViewport;
    viewportDelegate = new EditorViewportDelegate;
    viewportDelegate.addViewport(viewport2d);
    viewportDelegate.addViewport(viewport3d);
    width = $(".editor_panel").width();
    height = $(".editor_panel").height();
    editor2dview = new Editor2DView({
      el: $(".edit_area"),
      model: viewport2d,
      width: width,
      height: height
    });
    editor3dview = new Editor3DView({
      el: $(".view_area"),
      model: viewport3d,
      width: width,
      height: height
    });
    editor['view2d'] = editor2dview;
    editor['view3d'] = editor3dview;
    return $(document).on('click', '.addToScene', function() {
      var $_this, type, url, _this;
      _this = this;
      $_this = $(this);
      type = $_this.attr('data-type');
      url = $_this.attr('data-url');
      if (_.indexOf(['wall'], type) >= 0) {
        return helper.getJSON(url, function(json) {
          return viewportDelegate.trigger('addMeshByJson', json);
        });
      }
    });
  });

}).call(this);
